# lectorius — data model

**version:** 1.2
**status:** draft
**last updated:** february 2026

---

## 1. overview

this document defines all data types used across the lectorius system:

- **pipeline output** (python/pydantic) — generated by the data pipeline
- **api layer** (typescript) — served by sveltekit api routes
- **client state** (typescript) — managed in svelte stores and localstorage

all three layers share the same logical schema. pipeline outputs json; api and client consume it as typescript types.

---

## 2. pipeline schemas (python/pydantic)

located in `pipeline/src/lectorius_pipeline/schemas.py`

```python
from pydantic import BaseModel
from typing import Literal
from datetime import datetime

# =============================================================================
# book metadata
# =============================================================================

class BookMeta(BaseModel):
    book_id: str
    title: str
    author: str | None = None
    language: str = "en"
    year: int | None = None
    book_type: Literal["fiction", "non-fiction", "biography"] = "fiction"
    source: str | None = None
    source_id: str | None = None
    status: Literal["available", "coming_soon"] = "available"
    tts_provider: Literal["openai", "elevenlabs"] | None = None
    voice_id: str | None = None

# =============================================================================
# manifest
# =============================================================================

class ManifestConfig(BaseModel):
    tts_voice_id: str = ""
    tts_model: str = ""
    chunk_target_chars: int = 600
    chunk_min_chars: int = 100
    chunk_max_chars: int = 1600
    checkpoint_interval_chunks: int = 50
    embedding_model: str = ""

class ManifestStats(BaseModel):
    chapters: int = 0
    chunks: int = 0
    total_audio_duration_ms: int = 0
    total_chars: int = 0

class Manifest(BaseModel):
    book_id: str
    version: int
    created_at: datetime
    updated_at: datetime
    pipeline_version: str
    stages_completed: list[str]
    config: ManifestConfig
    stats: ManifestStats

# =============================================================================
# chapters
# =============================================================================

class Chapter(BaseModel):
    book_id: str
    chapter_id: str             # format: {book_id}_ch{index:03d}
    index: int                  # 1-indexed
    title: str
    char_start: int             # inclusive offset in raw_text.txt
    char_end: int               # exclusive offset in raw_text.txt

# =============================================================================
# chunks
# =============================================================================

class Chunk(BaseModel):
    book_id: str
    chapter_id: str
    chunk_id: str               # format: {chapter_id}_{chunk_index:06d}
    chunk_index: int            # global 1-indexed position across entire book
    text: str
    char_start: int
    char_end: int

# =============================================================================
# playback map
# =============================================================================

class PlaybackMapEntry(BaseModel):
    chunk_id: str
    chapter_id: str
    chunk_index: int
    audio_path: str             # relative: audio/chunks/{chunk_id}.mp3
    duration_ms: int
    start_ms: int = 0           # always 0 for per-chunk audio
    end_ms: int                 # same as duration_ms

# =============================================================================
# rag metadata
# =============================================================================

class RAGMeta(BaseModel):
    vector_id: int              # 0-indexed position in meta.jsonl
    chunk_id: str
    chunk_index: int
    chapter_id: str

# =============================================================================
# memory checkpoints
# =============================================================================

class Person(BaseModel):
    name: str
    aliases: list[str]
    role: Literal["protagonist", "antagonist", "supporting", "mentioned"]
    description: str
    first_chunk: int
    last_chunk: int

class Place(BaseModel):
    name: str
    description: str
    first_chunk: int
    last_chunk: int

class PlotThread(BaseModel):
    id: str                     # format: thread_{NNN}
    description: str
    status: Literal["open", "resolved"]
    introduced_chunk: int
    last_updated_chunk: int

class Entities(BaseModel):
    people: list[Person]
    places: list[Place]
    open_threads: list[PlotThread]

class MemoryCheckpoint(BaseModel):
    book_id: str
    checkpoint_index: int
    until_chunk_index: int
    until_chunk_id: str
    summary: str
    entities: Entities
```

---

## 3. api/client schemas (typescript)

located in `apps/web/src/lib/types.ts`

```typescript
// =============================================================================
// book metadata
// =============================================================================

export interface BookMeta {
  book_id: string;
  title: string;
  author: string | null;
  language: string;
  year: number | null;
  book_type: 'fiction' | 'non-fiction' | 'biography';
  source: string | null;
  source_id: string | null;
  status?: 'available' | 'coming_soon';  // defaults to 'available'
  tts_provider?: 'openai' | 'elevenlabs';
  voice_id?: string;
}

// =============================================================================
// manifest
// =============================================================================

export interface ManifestConfig {
  tts_voice_id: string;
  tts_model: string;
  chunk_target_chars: number;
  chunk_min_chars: number;
  chunk_max_chars: number;
  checkpoint_interval_chunks: number;
  embedding_model: string;
}

export interface ManifestStats {
  chapters: number;
  chunks: number;
  total_audio_duration_ms: number;
  total_chars: number;
}

export interface Manifest {
  book_id: string;
  version: number;
  created_at: string;
  updated_at: string;
  pipeline_version: string;
  stages_completed: string[];
  config: ManifestConfig;
  stats: ManifestStats;
}

// =============================================================================
// chapters
// =============================================================================

export interface Chapter {
  book_id: string;
  chapter_id: string;
  index: number;
  title: string;
  char_start: number;
  char_end: number;
}

// =============================================================================
// chunks
// =============================================================================

export interface Chunk {
  book_id: string;
  chapter_id: string;
  chunk_id: string;
  chunk_index: number;
  text: string;
  char_start: number;
  char_end: number;
}

// =============================================================================
// playback map
// =============================================================================

export interface PlaybackMapEntry {
  chunk_id: string;
  chapter_id: string;
  chunk_index: number;
  audio_path: string;
  duration_ms: number;
  start_ms: number;
  end_ms: number;
}

// =============================================================================
// memory checkpoints
// =============================================================================

export type PersonRole = 'protagonist' | 'antagonist' | 'supporting' | 'mentioned';
export type ThreadStatus = 'open' | 'resolved';

export interface Person {
  name: string;
  aliases: string[];
  role: PersonRole;
  description: string;
  first_chunk: number;
  last_chunk: number;
}

export interface Place {
  name: string;
  description: string;
  first_chunk: number;
  last_chunk: number;
}

export interface PlotThread {
  id: string;
  description: string;
  status: ThreadStatus;
  introduced_chunk: number;
  last_updated_chunk: number;
}

export interface Entities {
  people: Person[];
  places: Place[];
  open_threads: PlotThread[];
}

export interface MemoryCheckpoint {
  book_id: string;
  checkpoint_index: number;
  until_chunk_index: number;
  until_chunk_id: string;
  summary: string;
  entities: Entities;
}

// =============================================================================
// loaded book (client-side, in-memory)
// =============================================================================

export interface LoadedBook {
  book: BookMeta;
  chapters: Chapter[];
  chunks: Chunk[];
  playbackMap: PlaybackMapEntry[];
  checkpoints: MemoryCheckpoint[];
  cover_video_url: string | null;
}

// =============================================================================
// book library item
// =============================================================================

export interface BookListItem {
  book_id: string;
  title: string;
  author: string | null;
  cover_url: string | null;
  cover_video_url: string | null;
  total_chapters: number;
  total_chunks: number;
  total_duration_ms: number;
  status?: 'available' | 'coming_soon';
}
```

---

## 4. client state types (typescript)

located in `apps/web/src/lib/stores/types.ts`

```typescript
// =============================================================================
// playback state
// =============================================================================

export type PlaybackSpeed = 1 | 1.5 | 2;

export interface PlaybackState {
  book_id: string | null;
  chunk_index: number;
  chunk_time_ms: number;
  is_playing: boolean;
  playback_speed: PlaybackSpeed;
  volume: number;
  sleep_timer_end: number | null;
}

export const DEFAULT_PLAYBACK_STATE: PlaybackState = {
  book_id: null,
  chunk_index: 1,
  chunk_time_ms: 0,
  is_playing: false,
  playback_speed: 1,
  volume: 1,
  sleep_timer_end: null
};

// =============================================================================
// q&a state
// =============================================================================

export interface QAState {
  is_recording: boolean;
  is_processing: boolean;
  is_playing_answer: boolean;
  last_question: string | null;
  last_answer: string | null;
  error: string | null;
}

export const DEFAULT_QA_STATE: QAState = {
  is_recording: false,
  is_processing: false,
  is_playing_answer: false,
  last_question: null,
  last_answer: null,
  error: null,
};

// =============================================================================
// book store state
// =============================================================================

export interface BookStoreState {
  loaded_book: LoadedBook | null;
  is_loading: boolean;
  error: string | null;
}

export const DEFAULT_BOOK_STATE: BookStoreState = {
  loaded_book: null,
  is_loading: false,
  error: null,
};
```

---

## 5. persisted state (localstorage)

```typescript
// key: "lectorius_playback"
// per-book positions keyed by book_id
export interface BookPosition {
  chunk_index: number;
  chunk_time_ms: number;
}

export type SavedPositions = Record<string, BookPosition>;
// example: { "pride-and-prejudice": { chunk_index: 12, chunk_time_ms: 3400 },
//            "rip-van-winkle": { chunk_index: 5, chunk_time_ms: 0 } }

// key: "lectorius_user"
// plain string — the user's display name
// example: "Alice"

// key: "lectorius_theme"
// plain string — "light" | "dark" | "system"

// key: "lectorius_music"
// persisted subset of MusicState (see section 5b)
interface PersistedMusic {
  current_playlist_id: string | null;
  current_song_index: number;
  current_time: number;
  volume: number;            // 0-100
  loop: boolean;
  sync_with_book: boolean;
}

// key: "lectorius_reading_history"
// per-book history keyed by book_id
export interface ReadingHistoryEntry {
  book_id: string;
  last_chunk_index: number;
  total_chunks: number;
  last_played: number;       // Date.now() timestamp
}

export type SavedHistory = Record<string, ReadingHistoryEntry>;
```

---

## 6. api request/response types

```typescript
// GET /api/books
export interface GetBooksResponse {
  books: BookListItem[];
}

// GET /api/books/[id]
export interface GetBookResponse {
  book: BookMeta;
  chapters: Chapter[];
  chunks: Chunk[];
  playback_map: PlaybackMapEntry[];
  checkpoints: MemoryCheckpoint[];
  cover_video_url: string | null;
}

// POST /api/ask
// request body (JSON):
interface AskRequest {
  book_id: string;
  chunk_index: number;
  audio_base64: string;        // base64-encoded webm audio
}
// headers: X-User-Name (optional)

// response: text/event-stream (SSE)
// each message is: data: {json}\n\n
//
// message types sent by server:
{ type: 'question', text: string }
{ type: 'audio', text: string, audio: string }  // audio = base64 mp3
{ type: 'done', full_answer: string }
{ type: 'error', error?: string, fallback_audio_url: string }

// non-SSE error responses (JSON, from hooks middleware):
{ error: 'Too many questions. Try again later.' }  // 429
{ error: 'Free limit reached' }                     // 403
{ error: 'Service temporarily unavailable' }        // 503

// POST /api/verify-code
// request body:
interface VerifyCodeRequest {
  code: string;
  user_name?: string;
}
// response:
{ success: true }                                    // 200 (sets httpOnly cookie)
{ success: false, error: string }                    // 400 | 401 | 500

// GET /api/music/playlists
interface GetPlaylistsResponse {
  playlists: {
    playlist_id: string;
    name: string;
    type: 'general' | 'book';
    book_id: string | null;
    songs: { title: string; file_url: string }[];
  }[];
}
```

---

## 7. system audio (fallbacks)

fallback audio is stored in supabase storage under two paths:

**generic fallbacks** — `system/audio/{id}.mp3`
used when no per-voice version exists or as a last resort.

**per-voice fallbacks** — `system/fallback-audio/{voice_id}/{id}.mp3`
generated by the `lectorius-pipeline generate-fallbacks` CLI command.
each book's `voice_id` (from book.json) gets its own set of fallbacks
so the error/fallback voice matches the narrator voice.

the server resolves fallback URLs via:
```
if (voiceId) → {SUPABASE_URL}/storage/v1/object/public/system/fallback-audio/{voiceId}/{id}.mp3
else         → {SUPABASE_URL}/storage/v1/object/public/system/audio/{id}.mp3
```

| fallback id | text | use case |
|-------------|------|----------|
| `no_context_yet` | "i don't have enough context yet—let's keep reading." | question before chunk 5 |
| `error` | "i can't seem to find an answer right now." | api/tts failure |

---

## 8. id formats

| entity | format | example |
|--------|--------|---------|
| book_id | lowercase slug | `pride-and-prejudice` |
| chapter_id | `{book_id}_ch{index:03d}` | `pride-and-prejudice_ch001` |
| chunk_id | `{chapter_id}_{chunk_index:06d}` | `pride-and-prejudice_ch001_000042` |
| checkpoint_index | 1-indexed integer | `5` |
| thread_id | `thread_{NNN}` | `thread_001` |

current books: `rip-van-winkle`, `a-christmas-carol`, `pride-and-prejudice`, `metamorphosis`, `great-gatsby` (pending), `yellow-wallpaper` (legacy)

---

## 8b. music types

located in `apps/web/src/lib/stores/music.ts`

```typescript
export interface Song {
  title: string;
  file_url: string;
  duration_ms: number;       // set at runtime from audio metadata
}

export interface Playlist {
  playlist_id: string;
  name: string;
  type: 'general' | 'book';
  book_id: string | null;
  songs: Song[];
}

export interface MusicState {
  current_playlist_id: string | null;
  current_song_index: number;
  current_time: number;
  volume: number;            // 0-100
  loop: boolean;
  is_playing: boolean;
  ducked: boolean;           // lowered during Q&A
  sync_with_book: boolean;   // auto-switch playlist when book changes
}
```

---

## 8c. database tables (supabase postgres)

```sql
-- embedding vectors for RAG similarity search (pgvector)
-- populated by pipeline RAG stage, queried by web app /api/ask
CREATE TABLE book_embeddings (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  book_id text NOT NULL,
  chunk_id text NOT NULL,
  chunk_index integer NOT NULL,
  chapter_id text NOT NULL,
  embedding vector(1536) NOT NULL
);
CREATE INDEX ON book_embeddings USING ivfflat (embedding vector_cosine_ops);

-- valid access codes for unlimited Q&A
CREATE TABLE access_codes (
  id serial PRIMARY KEY,
  code text UNIQUE NOT NULL,
  created_at timestamptz DEFAULT now()
);

-- logs every Q&A question (used for free-tier counting by IP)
CREATE TABLE question_log (
  id serial PRIMARY KEY,
  ip text,
  user_name text,
  book_id text,
  question text,
  created_at timestamptz DEFAULT now()
);

-- logs every access code redemption
CREATE TABLE code_usage_log (
  id serial PRIMARY KEY,
  code text,
  ip text,
  user_name text,
  created_at timestamptz DEFAULT now()
);

-- music playlists (general ambient + per-book themed)
CREATE TABLE playlists (
  playlist_id text PRIMARY KEY,
  name text NOT NULL,
  type text NOT NULL,          -- 'general' | 'book'
  book_id text,                -- null for general playlists
  folder_path text NOT NULL    -- supabase storage path
);
```

---

## 9. validation rules

### book id
- lowercase alphanumeric + hyphens only
- 3-50 characters
- pattern: `^[a-z0-9][a-z0-9-]{1,48}[a-z0-9]$`

### chunk index
- 1-indexed
- sequential within book (no gaps)
- must match between `chunks.jsonl` and `playback_map.jsonl`

### timestamps
- iso 8601 format with timezone: `2025-06-15T14:32:00Z`
- durations in milliseconds (integer)

### text
- utf-8 encoded
- whitespace normalized
- no null bytes

---

## 10. schema export

export json schema from pydantic for validation:

```python
# pipeline/scripts/export_schemas.py
import json
from lectorius_pipeline.schemas import (
    BookMeta, Manifest, Chapter, Chunk,
    PlaybackMapEntry, RAGMeta, MemoryCheckpoint
)

schemas = {
    "BookMeta": BookMeta.model_json_schema(),
    "Manifest": Manifest.model_json_schema(),
    "Chapter": Chapter.model_json_schema(),
    "Chunk": Chunk.model_json_schema(),
    "PlaybackMapEntry": PlaybackMapEntry.model_json_schema(),
    "RAGMeta": RAGMeta.model_json_schema(),
    "MemoryCheckpoint": MemoryCheckpoint.model_json_schema(),
}

with open("schemas/book_pack.json", "w") as f:
    json.dump(schemas, f, indent=2)
```
