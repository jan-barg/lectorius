# lectorius — data model

**version:** 1.1
**status:** draft
**last updated:** february 2026

---

## 1. overview

this document defines all data types used across the lectorius system:

- **pipeline output** (python/pydantic) — generated by the data pipeline
- **api layer** (typescript) — served by sveltekit api routes
- **client state** (typescript) — managed in svelte stores and localstorage

all three layers share the same logical schema. pipeline outputs json; api and client consume it as typescript types.

---

## 2. pipeline schemas (python/pydantic)

located in `pipeline/src/lectorius_pipeline/schemas.py`

```python
from pydantic import BaseModel
from typing import Literal
from datetime import datetime

# =============================================================================
# book metadata
# =============================================================================

class BookMeta(BaseModel):
    book_id: str
    title: str
    author: str | None
    language: str
    year: int | None
    book_type: Literal["fiction", "non-fiction", "biography"]
    source: str | None
    source_id: str | None

# =============================================================================
# manifest
# =============================================================================

class ManifestConfig(BaseModel):
    tts_voice_id: str
    tts_model: str
    chunk_target_chars: int
    chunk_min_chars: int
    chunk_max_chars: int
    checkpoint_interval_chunks: int
    embedding_model: str

class ManifestStats(BaseModel):
    chapters: int
    chunks: int
    total_audio_duration_ms: int
    total_chars: int

class Manifest(BaseModel):
    book_id: str
    version: int
    created_at: datetime
    updated_at: datetime
    pipeline_version: str
    stages_completed: list[str]
    config: ManifestConfig
    stats: ManifestStats

# =============================================================================
# chapters
# =============================================================================

class Chapter(BaseModel):
    book_id: str
    chapter_id: str             # format: {book_id}_ch{index:03d}
    index: int                  # 1-indexed
    title: str
    char_start: int             # inclusive offset in raw_text.txt
    char_end: int               # exclusive offset in raw_text.txt

# =============================================================================
# chunks
# =============================================================================

class Chunk(BaseModel):
    book_id: str
    chapter_id: str
    chunk_id: str               # format: {chapter_id}_{chunk_index:06d}
    chunk_index: int            # global 1-indexed position across entire book
    text: str
    char_start: int
    char_end: int

# =============================================================================
# playback map
# =============================================================================

class PlaybackMapEntry(BaseModel):
    chunk_id: str
    chapter_id: str
    chunk_index: int
    audio_path: str             # relative: audio/chunks/{chunk_id}.mp3
    duration_ms: int
    start_ms: int               # always 0 for per-chunk audio
    end_ms: int                 # same as duration_ms

# =============================================================================
# rag metadata
# =============================================================================

class RAGMeta(BaseModel):
    vector_id: int              # index in faiss, 0-indexed
    chunk_id: str
    chunk_index: int
    chapter_id: str

# =============================================================================
# database tables (supabase postgres + pgvector)
# =============================================================================

# book_embeddings — stores embedding vectors for similarity search
# populated by pipeline RAG stage, queried by web app /api/ask
#
# CREATE TABLE book_embeddings (
#   id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
#   book_id text NOT NULL,
#   chunk_id text NOT NULL,
#   chunk_index integer NOT NULL,
#   chapter_id text NOT NULL,
#   embedding vector(1536) NOT NULL
# );
#
# CREATE INDEX ON book_embeddings USING ivfflat (embedding vector_cosine_ops);

# =============================================================================
# memory checkpoints
# =============================================================================

class Person(BaseModel):
    name: str
    aliases: list[str]
    role: Literal["protagonist", "antagonist", "supporting", "mentioned"]
    description: str
    first_chunk: int
    last_chunk: int

class Place(BaseModel):
    name: str
    description: str
    first_chunk: int
    last_chunk: int

class PlotThread(BaseModel):
    id: str                     # format: thread_{NNN}
    description: str
    status: Literal["open", "resolved"]
    introduced_chunk: int
    last_updated_chunk: int

class Entities(BaseModel):
    people: list[Person]
    places: list[Place]
    open_threads: list[PlotThread]

class MemoryCheckpoint(BaseModel):
    book_id: str
    checkpoint_index: int
    until_chunk_index: int
    until_chunk_id: str
    summary: str
    entities: Entities
```

---

## 3. api/client schemas (typescript)

located in `apps/web/src/lib/types.ts`

```typescript
// =============================================================================
// book metadata
// =============================================================================

export interface BookMeta {
  book_id: string;
  title: string;
  author: string | null;
  language: string;
  year: number | null;
  book_type: 'fiction' | 'non-fiction' | 'biography';
  source: string | null;
  source_id: string | null;
}

// =============================================================================
// manifest
// =============================================================================

export interface ManifestConfig {
  tts_voice_id: string;
  tts_model: string;
  chunk_target_chars: number;
  chunk_min_chars: number;
  chunk_max_chars: number;
  checkpoint_interval_chunks: number;
  embedding_model: string;
}

export interface ManifestStats {
  chapters: number;
  chunks: number;
  total_audio_duration_ms: number;
  total_chars: number;
}

export interface Manifest {
  book_id: string;
  version: number;
  created_at: string;
  updated_at: string;
  pipeline_version: string;
  stages_completed: string[];
  config: ManifestConfig;
  stats: ManifestStats;
}

// =============================================================================
// chapters
// =============================================================================

export interface Chapter {
  book_id: string;
  chapter_id: string;
  index: number;
  title: string;
  char_start: number;
  char_end: number;
}

// =============================================================================
// chunks
// =============================================================================

export interface Chunk {
  book_id: string;
  chapter_id: string;
  chunk_id: string;
  chunk_index: number;
  text: string;
  char_start: number;
  char_end: number;
}

// =============================================================================
// playback map
// =============================================================================

export interface PlaybackMapEntry {
  chunk_id: string;
  chapter_id: string;
  chunk_index: number;
  audio_path: string;
  duration_ms: number;
  start_ms: number;
  end_ms: number;
}

// =============================================================================
// rag metadata
// =============================================================================

export interface RAGMeta {
  vector_id: number;
  chunk_id: string;
  chunk_index: number;
  chapter_id: string;
}

// =============================================================================
// memory checkpoints
// =============================================================================

export type PersonRole = 'protagonist' | 'antagonist' | 'supporting' | 'mentioned';
export type ThreadStatus = 'open' | 'resolved';

export interface Person {
  name: string;
  aliases: string[];
  role: PersonRole;
  description: string;
  first_chunk: number;
  last_chunk: number;
}

export interface Place {
  name: string;
  description: string;
  first_chunk: number;
  last_chunk: number;
}

export interface PlotThread {
  id: string;
  description: string;
  status: ThreadStatus;
  introduced_chunk: number;
  last_updated_chunk: number;
}

export interface Entities {
  people: Person[];
  places: Place[];
  open_threads: PlotThread[];
}

export interface MemoryCheckpoint {
  book_id: string;
  checkpoint_index: number;
  until_chunk_index: number;
  until_chunk_id: string;
  summary: string;
  entities: Entities;
}

// =============================================================================
// loaded book (client-side, in-memory)
// =============================================================================

export interface LoadedBook {
  book: BookMeta;
  manifest: Manifest;
  chapters: Chapter[];
  chunks: Chunk[];
  playbackMap: PlaybackMapEntry[];
  checkpoints: MemoryCheckpoint[];
}

// =============================================================================
// book library item
// =============================================================================

export interface BookListItem {
  book_id: string;
  title: string;
  author: string | null;
  cover_url: string | null;
  total_chapters: number;
  total_duration_ms: number;
}
```

---

## 4. client state types (typescript)

located in `apps/web/src/lib/stores/types.ts`

```typescript
// =============================================================================
// playback state
// =============================================================================

export type PlaybackSpeed = 1 | 1.5 | 2;

export interface PlaybackState {
  book_id: string | null;
  chunk_index: number;
  chunk_time_ms: number;
  is_playing: boolean;
  playback_speed: PlaybackSpeed;
  sleep_timer_end: number | null;
}

export const DEFAULT_PLAYBACK_STATE: PlaybackState = {
  book_id: null,
  chunk_index: 1,
  chunk_time_ms: 0,
  is_playing: false,
  playback_speed: 1,
  sleep_timer_end: null,
};

// =============================================================================
// q&a state
// =============================================================================

export interface QAState {
  is_recording: boolean;
  is_processing: boolean;
  is_playing_answer: boolean;
  last_question: string | null;
  last_answer: string | null;
  error: string | null;
}

export const DEFAULT_QA_STATE: QAState = {
  is_recording: false,
  is_processing: false,
  is_playing_answer: false,
  last_question: null,
  last_answer: null,
  error: null,
};

// =============================================================================
// book store state
// =============================================================================

export interface BookStoreState {
  loaded_book: LoadedBook | null;
  is_loading: boolean;
  error: string | null;
}

export const DEFAULT_BOOK_STATE: BookStoreState = {
  loaded_book: null,
  is_loading: false,
  error: null,
};
```

---

## 5. persisted state (localstorage)

```typescript
// key: "lectorius_playback"
// per-book positions keyed by book_id
export interface BookPosition {
  chunk_index: number;
  chunk_time_ms: number;
}

export type SavedPositions = Record<string, BookPosition>;
// example: { "yellow-wallpaper": { chunk_index: 12, chunk_time_ms: 3400 },
//            "rip-van-winkle": { chunk_index: 5, chunk_time_ms: 0 } }

// key: "lectorius_settings"
export interface StoredSettings {
  playback_speed: PlaybackSpeed;
  volume: number;
}

export const DEFAULT_SETTINGS: StoredSettings = {
  playback_speed: 1,
  volume: 1.0,
};
```

---

## 6. api request/response types

```typescript
// GET /api/books
export interface GetBooksResponse {
  books: BookListItem[];
}

// GET /api/books/[id]
export interface GetBookResponse {
  book: BookMeta;
  manifest: Manifest;
  chapters: Chapter[];
  chunks: Chunk[];
  playback_map: PlaybackMapEntry[];
  checkpoints: MemoryCheckpoint[];
}

// POST /api/ask
export interface AskRequest {
  book_id: string;
  chunk_index: number;
  chunk_time_ms: number;
  audio: Blob;
}

export interface AskResponseSuccess {
  success: true;
  question_text: string;
  answer_text: string;
  answer_audio: string;
}

export type FallbackAudioId = 'error' | 'book_only' | 'no_context_yet';

export interface AskResponseError {
  success: false;
  error: string;
  fallback_audio_id: FallbackAudioId;
}

export type AskResponse = AskResponseSuccess | AskResponseError;
```

---

## 7. system audio (fallbacks)

pre-recorded audio stored in `system/audio/`:

| file | fallback id | text | use case |
|------|-------------|------|----------|
| `no_context_yet.mp3` | `no_context_yet` | "i don't have enough context yet—let's keep reading." | question in first 30 sec |
| `book_only.mp3` | `book_only` | "i can only help with questions about this book." | off-topic question |
| `error.mp3` | `error` | "i can't seem to find an answer right now." | api failure |
| `resuming.mp3` | — | "let's get back to the story." | after q&a (optional) |

---

## 8. id formats

| entity | format | example |
|--------|--------|---------|
| book_id | lowercase slug | `great-gatsby` |
| chapter_id | `{book_id}_ch{index:03d}` | `great-gatsby_ch001` |
| chunk_id | `{chapter_id}_{chunk_index:06d}` | `great-gatsby_ch001_000042` |
| checkpoint_index | 1-indexed integer | `5` |
| thread_id | `thread_{NNN}` | `thread_001` |

---

## 9. validation rules

### book id
- lowercase alphanumeric + hyphens only
- 3-50 characters
- pattern: `^[a-z0-9][a-z0-9-]{1,48}[a-z0-9]$`

### chunk index
- 1-indexed
- sequential within book (no gaps)
- must match between `chunks.jsonl` and `playback_map.jsonl`

### timestamps
- iso 8601 format with timezone: `2025-06-15T14:32:00Z`
- durations in milliseconds (integer)

### text
- utf-8 encoded
- whitespace normalized
- no null bytes

---

## 10. schema export

export json schema from pydantic for validation:

```python
# pipeline/scripts/export_schemas.py
import json
from lectorius_pipeline.schemas import (
    BookMeta, Manifest, Chapter, Chunk,
    PlaybackMapEntry, RAGMeta, MemoryCheckpoint
)

schemas = {
    "BookMeta": BookMeta.model_json_schema(),
    "Manifest": Manifest.model_json_schema(),
    "Chapter": Chapter.model_json_schema(),
    "Chunk": Chunk.model_json_schema(),
    "PlaybackMapEntry": PlaybackMapEntry.model_json_schema(),
    "RAGMeta": RAGMeta.model_json_schema(),
    "MemoryCheckpoint": MemoryCheckpoint.model_json_schema(),
}

with open("schemas/book_pack.json", "w") as f:
    json.dump(schemas, f, indent=2)
```
